# Operator
# Operator란?
주어진 식을 계산하여 결과를 얻어내는 과정을 연산이라고 하며 연산을 수행하는 기호를 연산자라고 함
- 연산자: 연산을 수행하는 기호(+,-,*,/)
- 피연산자: 연산자의 작업 대상(변수, 상수, 수식)

# 연산자 종류
### 단항 연산자: +, 1, ~, !
    - 피연산자가 오직 하나만 필요한 연산자
    - !는 현재 논리값을 부정하는 의미이며 true일 경우 false로, false일 경우 true로 변환
    - ~는 부정 연산자이며 연산을 할 때 피연산자를 int형으로 변환시키고 0은 1로, 1은 0으로 바꾸는 역할을 함

##### 증감 연산자: ++, --
    - 증가 연산자(++) : 피연산자의 값을 1 증가시킴
    - 감소 연산자(--) : 피연산자의 값을 1 감소 시킴
      - 전위형: 값이 참조 되기 전에 증가/감소 (++i)
      - 후위형: 값이 참조 된 후에 증가/감소 (i++)

### 이항 연산자
##### 1. 산술 연산자: +, -, *, /, %
    - 기본적인 사칙연산과 나머지 연산을 하는 가장 기본이 되는 연산자
    - 시프트 연산자: <<,>>,>>>
       : 시프트 연산자는 변수나 어떤 수의 비트를 이동시키는 연산자
       : <<는 대상을 이진수로 바꾼 후 왼쪽으로 비트들을 옮기는 작업 수행, 이 때 빈자리는 0으로 채움
         ~ 처럼 비트를 직접 다루기 때문에 모든 변수 타입을 int형으로 변환한 후 사용됨
       : >> 또한 대상을 이진수로 바꾼 후 오른쪽으로 비트들을 옮기는 작업을 수행함
       : >>> 는 기본적으로 >> 와 원리는 같음, 하지만 원 데이터가 음수일 경우에도 앞쪽 비트를 0으로 채움, 오로지 양수 값만 다룰 수 있음

##### 2. 비교(관계) 연산자: >,<,<=,>=,==,!=
    - 연산자의 왼쪽과 오른쪽의 피연산자들의 크기 고나계를 비교하여 참과 거짓을 가리는 연산자

##### 3. 논리 연산자: &&, ||
    - &&는 두 피연산자의 값이 모두 true일 경우 true 값을, 하나라도 false일 경우에는 false값을 결과로 반환
    - ||는 두 피연산자 중 하나라도 true일 경우 값을 반환
    - 여기에는 비트 연산자도 포함되는데 이진수로 변환되어 작업을 수행하는 연산자임
    - 비트연산자: &, ^, |
    - &(and 연산자) : 두 개의 피연산자 모두 1이어야 결과값 1을 얻음, 그 외에는 결과값 0을 얻음
    - |(or 연산자) : 두 개의 피연산자 중 한 개의 피연산자 값이 1이면 결과값은 1, 그 외에는 결과값 0을 얻음
    - ^(xor 연산자) : 두 개의 피연산자의 값이 서로 다를 때만 결과값 1을 얻음, 같을 때는 0을 얻음
    - ~(not 연산자) : 각 비트를 반전 시킨 값을 반환

### 삼항 연산자: ?,:
    - 항1: 항2 구조로 사용
    - 조건항이 참일 경우 항1의 값을 반환하고 조건항이 거짓일 경우 항2의 값을 반환함
    - ex) int a= 10, int b= 20일 때, a>b ? a : b =? b 반환

### 대입 연산자: =
    - 값을 변수에 대입하는 연산자

### switch 연산자
    - java12부터 preview로 업데이트 된 기능
    - java13부터 yield 키워드 도입
    - 화살표 연산자(->) 사용 가능

```java
// java 12 이전
int num = 1;
int returnNum = 0;
switch (num) {
    case 1:
        returnNum = 1;
        System.out.println("1들어와");
        break;
    case 2:
        returnNum = 2;
        System.out.println("2들어와");
        break;
}
System.out.println("returnNum: " + "[" + returnNum + "]"); // 1

// java 12
// ->(화살표) 표현이 가능하고 data만 존재할 경우 return이 가능함
// -> 구문을 사용할 경우 break;를 적지 않아도 다음 case 구문으로 넘어가지 않음
// -> 표현 오른쪽은 꼭 단일 수행일 필요가 없음 {} 안에서의 작업도 가능함
returnNum = switch(num) {
    case 1 -> 1;
    case 2 -> 2;
    default -> throw new IllegalStateException("Unexpected Value: " + num);
}
System.out.println("returnNum: " + "[" + returnNum + "]"); // 1

// java 13
// yield 예약어 추가 (yield x => x 리턴)
// yield는 예약어이지만 변수명으로도 사용 가능함 (int yield = 3;)
returnNum = switch(num) {
    case 1 : yield 3;
    default: throw new IllegalStateException("Unexpected Value: " + num);
}
System.out.println("returnNum: " + "[" + returnNum + "]"); // 3
```

# 연산자 우선순위
- 산술 연산식에서 덧셈, 뺄셈보다 곱셉, 나눗셈 연산자가 우선 처리됨
- <,> 비교 연산이 먼저 수행된 후 && 연산이 처리되어 최종 값이 반환됨
- **** 연산자 우선순위가 같으면, 연산 방향에 따라 달라짐(ex: 100 * 2 / 3 % 5)
    -> 모든 연산자들이 우선순위가 같을 경우 연산 방향이 왼쪽으로 오른쪽이므로 값은 1
- 단항 > 이항 > 삼항 > 대입
- 산술 > 비교 > 논리 > 

![image](https://user-images.githubusercontent.com/53419498/114373661-cae40f00-9bbd-11eb-9b37-89f34a18781a.png)    
   
    
- 정리
    - 단항, 이항, 삼항 연산자 순으로 우선순위를 가짐
    - 산술, 비교, 논리, 대입 연산자 순으로 우선순위를 가짐
    - 단항과 대입 연산자를 제외한 모든 연산 방향은 왼쪽에서 오른쪽
    - 복잡한 연산식에는 () 괄호를 사용하여 우선순위를 정함
